#!/bin/bash

# exiflint_batch - Optimized batch version for checking EXIF geolocation data
# Exit codes: 0=pass, 1=gps data found, 2=invalid params

set -euo pipefail

# Script variables
VERBOSE=false
RECURSIVE=false
FAILED_FILES=()
FAILED_COUNT=0

usage() {
    cat << EOF
Usage: $0 [-r] [-v] [files/directories...]

Check images for EXIF geolocation data that could be personally identifiable.
Optimized batch version for faster processing of many files.

Options:
  -r    Recursively search directories
  -v    Verbose output (show each file checked)
  -h    Show this help

Exit codes:
  0     No GPS data found in any images
  1     GPS data found in one or more images
  2     Invalid parameters or execution error

If GPS data is found, the names of affected images are printed to stdout.
EOF
}

# Check if required tools are available
check_dependencies() {
    if ! command -v exiftool &> /dev/null; then
        echo "Error: exiftool is required but not installed" >&2
        echo "Install with: sudo apt install libimage-exiftool-perl" >&2
        exit 2
    fi
}

# Find all potential image files using file command in batch
find_images() {
    local paths=("$@")
    local find_opts=(-type f)
    
    if [[ "$RECURSIVE" == false ]]; then
        find_opts+=(-maxdepth 1)
    fi
    
    # Build list of all files to check
    local all_files=()
    for path in "${paths[@]}"; do
        if [[ -f "$path" ]]; then
            all_files+=("$path")
        elif [[ -d "$path" ]]; then
            while IFS= read -r -d '' file; do
                all_files+=("$file")
            done < <(find "$path" "${find_opts[@]}" -print0 2>/dev/null || true)
        fi
    done
    
    if [[ ${#all_files[@]} -eq 0 ]]; then
        return
    fi
    
    # Use file command in batch to identify images
    local temp_file_list
    temp_file_list=$(mktemp)
    printf '%s\n' "${all_files[@]}" > "$temp_file_list"
    
    # Process files in batch with file command
    while IFS= read -r line; do
        if [[ "$line" =~ ^([^:]+):[[:space:]]*(.*)$ ]]; then
            local file="${BASH_REMATCH[1]}"
            local file_type="${BASH_REMATCH[2]}"
            
            # Check for image formats that support EXIF metadata
            case "$file_type" in
            *JPEG*|*"JFIF"*|*"Exif"*) echo "$file" ;;
            *TIFF*|*"Tagged Image File Format"*) echo "$file" ;;
            *PNG*|*"Portable Network Graphics"*) echo "$file" ;;
            *WebP*) echo "$file" ;;
            *HEIC*|*HEIF*) echo "$file" ;;
            # RAW camera formats
            *Canon*|*Nikon*|*Sony*|*Fuji*|*Olympus*|*Panasonic*|*Pentax*|*Samsung*) echo "$file" ;;
            *CR2*|*NEF*|*ARW*|*DNG*|*RAF*|*ORF*|*PEF*|*RW2*|*SRW*) echo "$file" ;;
            esac
        fi
    done < <(xargs -r -a "$temp_file_list" file)
    
    rm "$temp_file_list"
}

# Process images in batch using exiftool
process_images_batch() {
    local image_files=()
    while IFS= read -r -d '' file; do
        image_files+=("$file")
    done < <(find_images "$@" | tr '\n' '\0')
    
    if [[ ${#image_files[@]} -eq 0 ]]; then
        return 0
    fi
    
    
    # Create temporary file for batch processing
    local temp_file_list
    temp_file_list=$(mktemp)
    printf '%s\n' "${image_files[@]}" > "$temp_file_list"
    
    # Process all images in single exiftool call
    local gps_output
    gps_output=$(xargs -r -a "$temp_file_list" exiftool -GPS:all 2>/dev/null || true)
    
    # For single file, exiftool doesn't output headers, so handle differently
    if [[ ${#image_files[@]} -eq 1 ]]; then
        local single_file="${image_files[0]}"
        if [[ -n "$gps_output" && "$gps_output" != *"image files read" ]]; then
            # GPS data found
            FAILED_FILES+=("$single_file")
            FAILED_COUNT=$((FAILED_COUNT + 1))
            
            if [[ "$VERBOSE" == true ]]; then
                echo "$single_file: FAIL"
            fi
        elif [[ "$VERBOSE" == true ]]; then
            echo "$single_file: PASS"
        fi
    else
        # Multiple files - parse with headers
        local current_file=""
        local has_gps_data=""
        
        while IFS= read -r line; do
            if [[ "$line" =~ ^======== ]]; then
                # Process previous file if it had GPS data
                if [[ -n "$current_file" && -n "$has_gps_data" ]]; then
                    FAILED_FILES+=("$current_file")
                    FAILED_COUNT=$((FAILED_COUNT + 1))
                    
                    if [[ "$VERBOSE" == true ]]; then
                        echo "$current_file: FAIL"
                    fi
                elif [[ -n "$current_file" && "$VERBOSE" == true ]]; then
                    echo "$current_file: PASS"
                fi
                
                # Extract filename from exiftool header
                current_file="${line#======== }"
                has_gps_data=""
            elif [[ -n "$line" && "$line" != *"image files read" ]]; then
                # Non-empty line means GPS data exists
                has_gps_data="yes"
            fi
        done <<< "$gps_output"
        
        # Handle last file
        if [[ -n "$current_file" && -n "$has_gps_data" ]]; then
            FAILED_FILES+=("$current_file")
            FAILED_COUNT=$((FAILED_COUNT + 1))
            
            if [[ "$VERBOSE" == true ]]; then
                echo "$current_file: FAIL"
            fi
        elif [[ -n "$current_file" && "$VERBOSE" == true ]]; then
            echo "$current_file: PASS"
        fi
    fi
    
    rm "$temp_file_list"
}

# Parse command line arguments
while getopts "rvh" opt; do
    case $opt in
        r) RECURSIVE=true ;;
        v) VERBOSE=true ;;
        h) usage; exit 0 ;;
        *) echo "Invalid option. Use -h for help." >&2; exit 2 ;;
    esac
done

shift $((OPTIND-1))

# Check if any arguments provided
if [[ $# -eq 0 ]]; then
    echo "Error: No files or directories specified" >&2
    usage >&2
    exit 2
fi

# Validate arguments exist
for arg in "$@"; do
    if [[ ! -e "$arg" ]]; then
        echo "Error: '$arg' does not exist" >&2
        exit 2
    fi
done

# Check dependencies
check_dependencies

# Process all files in batch
process_images_batch "$@"

# Output results
if [[ ${#FAILED_FILES[@]} -gt 0 ]]; then
    # Print failed files to stdout (only if not verbose)
    if [[ "$VERBOSE" == false ]]; then
        printf '%s\n' "${FAILED_FILES[@]}"
    fi
    exit 1
else
    exit 0
fi